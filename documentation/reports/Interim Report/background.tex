\section{Background}
\subsection{Problem Context}
This problem's main focus is the difficulty of organising classical sheet music, and how this can be made easier by the automatic extraction of key pieces  of information. In order to understand what a performer may want to know about a particular piece, it is important to have a brief understanding of the elements of musical notation common to all compositions.
\subsubsection{Clefs}
As previously mentioned, the key element of sheet music is the staff, represented as five horizontal lines:

This is the one element which will be common to all pieces handled by the project. 

In order to indicate to the reader at which points a staff's pitches will be assigned, every piece will have a clef notation:

The most common clef is known as the treble, or G clef. The G clef indicates that the second line from the bottom of the staff denotes the pitch G, and therefore tells the reader that the space above will be an A, and the space below an F.

Clefs are an important piece of information to any musician as they indicate the range of pitches the piece is likely to contain - different pieces use a range of clef notations in order to ensure the majority of the notes used are on the staff, rather than above or below it, in order to make the piece easier to read. 

Furthermore, some musicians, such as Tuba players and Cello players, may not have yet learned how to read music in clefs other than the clef their instrument usually uses, which will make the score harder for them to read.

\subsubsection{Keys}
A second important indication to the player is the key, denoted by a key signature:

A collection of symbols at the beginning of the piece indicate which pitches should be raised by half pitches, and which should be lowered. Raised pitches are called sharps, indicated by the \# symbol, whilst lowered pitches are called flats, indicated by the [flat] symbol.

Further to this, each key has a name, named similarly to the individual pitches - the circle of fifths shows how keys link together and which keys can easily be transformed into others. \parencite{cofitfths}

This is a useful piece of notation to a musician as pieces in less common keys, such as C\# major or F\# major, may prove more difficult for the user to perform, and therefore they may want to filter out pieces in these particular keys. Similarly, in the case of singers, a singer's range may sit comfortably in one or two keys and they would perhaps want to find pieces in only these keys. 

\subsubsection{Meter}
The third symbol denoted at the beginning of a measure is the meter, two numerals positioned like a mathematical fraction:

The most common meter is 4/4, sometimes denoted by a C indicating "Common time". The upper number of a meter symbol indicates the amount of beats in the bar. A beat simply refers to a note or rest, and the type of beat is indicated by the lower number. In this case, 4/4 indicates a measure will contain 4 crotchets, or quarter-length notes - these are shown symbolically by this kind of note and rest:

This information is important as it tells the performer how the rhythm and beat of the piece should be felt, counted and performed, and is useful for searching purposes as different meters, or time signatures as they are sometimes referred to, give the piece a different feeling, dictating the sort of occasion this piece would accompany. 

For example, 2/4 is commonly used for march pieces, 3/4 is commonly used for waltzes and dance pieces, and 6/8 gives a similar, but more syncopated feel of a dance like piece.

\subsubsection{Tempo}
The speed of a particular piece, or the tempo, is indicated by an equation:

As explained above, this equation shows that the piece should be played at 60 crotchet beats per minute. Sometimes, this will be accompanied by a text direction to indicate speed or style, such as Andante, indicating a walking speed.

\subsubsection{Further metadata}
Aside from these symbols, there are some items of textual information useful to the user. 

The first of these would be the parts in the piece and their transpositions. Parts would be relevant as a particular group of instrumentalists may need parts that fit their instruments. If this is not the case for a given piece, however, a part written for a different instrument, for example, the Alto Saxophone rather than the Tenor Horn, may be compatible with the instrument anyway, if the transposition matches the instruments together.

Further to this, the user would want to know the piece's title, and names of publishers, composers, arrangers and lyricists of the work. Further to the composer name, it may be useful to know the date of composition as an indication of the piece's stylistic era, such as Classical/Baroque/Romantic, though this would not always be written on the sheet music so may need to be researched using the internet.


\subsection{Comparison of Technologies}
\subsubsection{Programming Language}
This project could be developed with a variety of programming languages, as displayed in the following table:

\begin{center}
\begin{tabular}{| l | c | c | r |} \hline
  {Language} & {Speed of development} & {Developer's Knowledge} & {Cross compatible} \\ \hline
  C\# & Fast & A lot & With difficulty \\ \hline
  Python & Fast & A lot & Yes \\ \hline
  C++ & Slow & Average & Yes \\ \hline
\end{tabular}
\end{center}
The three key elements the developer is focussing on are speed of development, as the time constraint of a year means it is important that development is not hindered by the language itself, developer knowledge as this will provide an additional time benefit, and cross compatibility, due to the different operating systems the developer intends to use in the course of development.

Due to these factors, Python has been selected. Further to these benefits, there are many projects in the field of musical software research currently in existence using this language, \parencite{pmus} which will help when trying to debug issues and build upon previous research.

\subsubsection{File format}
\paragraph{Creating a new file format}

It would be possible for this project to create it's own method of file storage, similar to methods used by commercial and open source composition software. This would enable the developer to build a format from the ground up, and design it around the way the system would work.

However, this project focusses on displaying and organising sheet music, and will not be allowing the user to create new sheet music from inside the program. Therefore, in order for the project to be a success it is important that the file format be compatible with popular composition software packages.

\paragraph{Using a previously created file format}

It would potentially be possible to examine files generated from popular packages such as Sibelius, the world's best-selling music composition software, \parencite{avid} or MuseScore, an open source offering to the composition industry. This would mean that the program would be directly compatible with the default files created by each package.

However, this would require further research into how each piece of software generates it's files, and in the case of Sibelius, may incur copyright issues due to Sibelius being commercial software. It would also mean the project would be tightly coupled with that file format, and if the developers of the original file format were to change it in future, modifications would have to be made frequently to the file handler.

\paragraph{Using a well documented music format}
The final choice considered is using a well documented music format referred to as MusicXML. This format was designed from the ground up to allow sharing of sheet music between programs, and in order to archive sheet music for the future. \parencite{mxml}

This file format is directly compatible with MuseScore, \parencite{MuseTour} and compatible with Sibelius version 7, and earlier versions through the use of a plug in. \parencite{Plugin} The MusicXML website provides a well documented tutorial on producing musicXML as well as a support forum and list of all tags available in musicXML.

However, using this file format means that some of the decisions on how to organise sheet music would have been made according another developer's wishes, which cannot be fixed or improved upon as would be possible if the developer chose to create their own file format.

The problem with tight coupling to this format may also be incurred, however, as this format is intended for sharing between programs, it is unlikely issues of backwards compatibility will occur.

\subsection{Comparison of Algorithms for Rendering and Organising Sheet Music}
\subsubsection{XML parsing algorithms}
\paragraph{DOM loading algorithm}
The first option is using a \textbf{DOM library} - in python, there are two built in libraries, called DOM (Document Object Model) and MiniDOM, a cut down version of the first. In this method, the entire XML file is loaded into memory, and the developer can look for specific tags and data using search functions.

This option has not been chosen for either objective. This is because for the purpose of rendering music, it may not be necessary to load all of the formatting information from the file, as well as some of the encoding data which composition software often puts into the file - this means that loading all of the data into memory is unnecessary. 

Secondly, the DOM library in python is not very easy to use and having to search for a specific tag name does not make for rapid development.
Thirdly, in reference to the searching and organising portion of the project, selection of metadata should not require a whole file of data, but rather select tags such as the instruments in the piece, composer, key, tempo and other such information.

\paragraph{SAX parsing algorithm}
SAX is a Simple API for XML processing, which parses the tags in the XML one by one, connecting to callbacks when specific things occur in XML parsing. This enables the developer to build up the functionality of object loading gradually, by connecting specific found tags to created handler methods, and allows for ignorance of tags which are not required.

Furthermore, in the area of metadata extraction, it is unlikely the process will require the entire file in order to extract key features of the piece, and therefore SAX parsing is far more suited to both tasks.

A further musical benefit to loading and rendering sheet music is that this method of parsing could enable the program to disregard notation considered to complex for the user to understand, for example when teaching a new student music theory.

\subsubsection{XML verification algorithms}
For both the algorithm options discussed in the above section, a further choice is whether to verify the XML parsed, using an online file validator, or presume the file is written in valid MusicXML. 

The usual choice is to verify all XML, and is therefore the default option for both methods of parsing. Whilst this confirms that XML is valid before starting parsing of a file which could be corrupt, the speed at which files will parse is greatly reduced according to the speed of the user's internet connection.
Furthermore, if the user is browsing their own music collection, it should not be necessary for the user to be connected to the internet.

Due to speed and functionality considerations, the choice has been made that the XML parser algorithm will not verify XML being converted to objects, or being examined for metadata. Given that most musicXML will be produced automatically by other programs, it is unlikely files opened by the project will be corrupt, though necessary steps will be taken to avoid this causing a problem in the program.

\subsubsection{Loading and memory management algorithm}
This project will load musicXML files for rendering into memory using a class structure, with each class providing it's own interface to output mechanisms. This has been decided as objects provide clean and navigatable structure, with the ability to inherit or overwrite parent class mechanisms.

It would also be possible to extract metadata from the musicXML files and create a converter directly to the output format for rendering, however this would make the structure harder to navigate and more difficult to debug, and would probably result in bad programming practices being used.



\subsubsection{Metadata algorithm}
The metadata algorithm has been designed so that, for a given folder, the program will parse all of the files with the XML extension for a given selection of information (for example, composer, piece title, instruments) and store this information in memory. 

This is to be indexed either by the information title - e.g "composer"; or by the information itself - e.g "bartok". This will facilitate faster searching of the database for use when the user is finding a particular piece, and facilitate auto generated playlists by the system. Depending on the method of indexing, the alternate indexer should be stored as part of the value in a key value pair format, alongside the file in which it was found.

In order to store this information, the following methods have been considered.

\paragraph{Using object oriented organisation}
It would be possible to store the information in a class structure, with each class holding the selected information and the file in which the metadata was found.

However, the described algorithm will only be storing 3 elements of data, all of which are strings, and therefore will not need a complex structure.

\paragraph{Using generics}
It has been decided to store all the information in a generic type, namely a dictionary. Dictionaries are built in to python and use intuitive syntax, and whilst this will necessitate having a dictionary of tuples due to needing to store 3 elements of data, this is a simpler organisatory structure.

A further point of discussion on this algorithm is how often the algorithm will need to run in order to have an accurate database:

\paragraph{Running the algorithm on every application open}
It would be possible to check and load all of the metadata for a particular folder each time the user opens the application. This would ensure if any file changes have been made that the metadata was up to date.

However, with testing, it has been found that this is a slow method owing to the volume of test data, and will only become slower if a user has a large collection of music. 

\paragraph{Caching previous runs}
It has been decided that the metadata algorithm will first check for a cached metadata file, created from a previous run of metadata parsing. It will then look for any files not in this cached file, parse the metadata from each file, and save out to the updated cache.

This avoids repeat loading of the same data, but if files are changed or updated after the first application open, it could cause confusion for the user. It may be possible to provide an option in the program to force the parser to re-run the metadata extraction on all files in the folder if this is an issue.

\subsubsection{Rendering Algorithm}
The program is required to take the object structure and transform it, in some way, to musician readable sheet music. 

\paragraph{Creating a new algorithm using fonts}
It would be possible to create sheet music using an algorithm designed by the developer. A potential option would be to create an automatic method of typesetting every class using music fonts layered on top of each other inside the render window.

This would give complexity and challenge to the developer and allow the developer to tailor optimisations according to speed and memory management.

However, this may create problems such as panning and zooming into the music which could prove complicated, how best to layer fonts on top of each other which may be difficult to do in a graphical window, and debugging the process would be difficult as it would require manually visually checking the algorithm functions and generates the correct sheet music.

Furthermore, music software has existed for a long time and the rendering algorithm will have been covered by many developers, who will have had longer to develop and test the solution, therefore developing a new algorithm may be considered reinventing the wheel.

\paragraph{Creating a new algorithm using images}
It may also be possible to apply the same algorithm, but generate an image which would then be displayed using a graphical viewer from a built in python graphics library, which would have the functionality for panning and zooming around the image built in. 

This still, however, leaves the problem of debugging the process manually, and the described issue with reinventing the wheel.

\paragraph{Outputting to a separate rendering program}
A third option is to have the program connect each class with a separate program, developed by a third party which will render the given symbols.

This removes a level of complexity and technical challenge, but avoids covering a research area which has already been done. Furthermore, this project's aim and main focus is to organise and import music, rather than render or create it, and recreating a rendering algorithm would not achieve this goal.

In addition to this, the issue with debugging music rendering would be alleviated as a third party program designed to render music would have been tested extensively, so the program could be debugged by simply ensuring outputs to the program are correct.

It has been decided to use this option and use Lilypond as the third party software. Lilypond is a cross-platform typesetting language, devoted to producing the highest-quality sheet music possible. \parencite{Lilypond} It has a large body of users and a well written collection of documentation. 

This will add a further technical challenge as it will be required to understand the syntax of Lilypond, and how Python should output Lilypond files for compilation and conversion to PDF.

\subsection{Comparison of Technologies for Importing Online Musical Sources}
\subsubsection{Musical Sources}
Two open and free sources of sheet music have been selected for potential inclusion, which will enable users to connect their own music collections with new music without using a browser to peruse collections. The first is \textbf{MuseScore Online}, which is a community website created for composers to upload share and discover compositions using the MuseScore platform. \parencite{MuseShare}

This has been selected due to the number of files available, the openness of the platform and the well documented API created by the developers. It will, however, be necessary to manage copyright issues, as pieces published on this website may be published under the license of the composer's choosing and therefore may cause issues with certain types of users, in particular those performing commercially.

The second selected source is the \textbf{IMSLP}. This is the \textbf{International Music Score Library Project}, built with the intention of sharing the worldâ€™s public domain music and contains 290,000 scores to date.\parencite{imslp} This may be a questionable source, as not all pieces are uploaded in MusicXML format due to the pieces being scanned and uploaded by community members, rather than being automatically generated by a piece of software. However, this source does not raise any copyright issues as all pieces are no longer covered by copyright.

It may also be possible to import collections from subscription services and websites enabling purchase of music, such as \textbf{MusicNotes.com}. However, this will require closer contact with the companies maintaining the website and may not be appropriate for an educational and academic purpose.

\subsubsection{Searching Algorithm}
The APIs for both selected sources provide a variety of output formats, the 2 most prominent being XML and JSON. 
It would be possible to use an algorithm which repeatedly connects to the API and polls for the relevant input from the user, returning a list of options which the user would then select from and download from the server. However, from the perspective of the user, this would be slow, requiring repeated connection to the internet. This would also cause problems for the maintainers of the server, as repeated requests from a piece of software would cause a heavy load on the server and be very unnecessary.

It has therefore been decided that the software will cache a copy of all metadata served from each online source, and search for the relevant inputted data from this, and then, if necessary, collect the relevant file from the server. This would require a connection to the server only twice - once when updating metadata sources, and once when downloading a file - rather than a persistent or repeated connection.
\subsection{Alternative Solutions}
\subsubsection{Commercial Software}
\subsubsection{Open Source Software}